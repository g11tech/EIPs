---
eip: 7742
title: Uncouple blob count between CL and EL
description: Have CL verify blob maximum and have EL get target value from CL
author: Alex Stokes (@ralexstokes), Gajinder Singh (@g11tech), Bert (@bkellerman)
discussions-to: https://ethereum-magicians.org/t/eip-7742-uncouple-blob-count-between-cl-and-el/20550
status: Review
type: Standards Track
category: Core
created: 2024-07-12
requires: 4844
---

## Abstract

Update blob maximum, target and blob gas fee computes from [EIP-4844](./eip-4844.md).

The execution layer no longer verifies the blob maximum and receives the target dynamically from the consensus layer.

## Motivation

Following EIP-4844, the execution layer (EL) maintains a hard-coded blob target value and blob maximum value. Given the relationship
of the EL and the consensus layer (CL) node software, the verification of the blob maximum is redundant so it can be removed
entirely without any change in security. The blob maximum is still provided during block construction via the Engine API.
This EIP also changes how the EL sources the current blob target value for two reasons:

1) Gain more flexibility over the value, rather than the static `TARGET == MAX // 2` relation in EIP-4844.

2) Uncouple development and deployment of the CL and EL layers in the event it is desirable to change the blob target value.

### Background

The data facility introduced via EIP-4844 adds blobs to Ethereum blocks, which are simply fixed sets of data that can be
included in the canonical chain but have no execution semantics (cf. `calldata` in an Ethereum transaction).

The protocol specifies a maximum allowed blob count per block to prevent DoS vectors via the abuse of this data facility.
The protocol also maintains an [EIP-1559](./eip-1559.md)-like "target" value for an intended running average amount of blob throughput per
unit time. Blob usage is compared against this target to influence a "blob base fee" to administer allocation of this
resource to users of the Ethereum protocol.

Both of these values are currently hard-coded in the EL after EIP-4844 and the blob maximum is separately hard-coded in
the CL following EIP-4844. This EIP proposes a set of changes to uncouple these values across the CL and EL to make development
and deployment of changes to the blob count easier.

#### Maximum blobs per block

The blob maximum is verified in the CL node and the EL inherits this verification during the consistency check of the versioned hashes corresponding to each blob as specified by the Engine API. Because of this, the strict check specified by EIP-4844 is unnecessary.

#### Target amount of blobs per block

The target is currently specified as a fixed value in relation to the blob count. The Ethereum community intends to increase the blob parameters as part of its scaling strategy and the ability to have a more flexible target value in relation to the blob max is desirable to reduce rigidity in this protocol parameter.

Even if the EL keeps a fixed target value based on the max, removing the max implies the EL would not know what the target value should be. To address this lack of information, this EIP proposes the CL sends the current target value to the EL with each provided payload over the Engine API. The EL block header will also need to be extended with this target value to preserve the security of optimistic sync.

#### Normalized excess blob gas

At any block we don't want the gas update factor (whether pushing gas up or down) to exceed ~1.125. This is essentially achieved in [EIP-4844](./eip-4844.md) by having an appropriate `BLOB_BASE_FEE_UPDATE_FRACTION` to divide `excess_blob_gas` accumulator while exponetiating it

Since the target from CL could theoratically change block to block, we need to normalize excess gas accumulation because the update fraction is actually directly based on the target (max value `excess_blob_gas` can jump by in a block).

We propose to "normalize" the gas diffs every block against its target and then accumulate in `excess_blob_gas` so that we accumulate normalized `excess_blob_gas` every block and can use a constant normalized update fraction in our fee calculations.

Note: CLs must also ensure that the target is always equal to or more than half the max otherwise we will need to also track the max for normalizing our gas calculations (otherwise full blocks will make the price jump by a factor of more than 1.125)

## Specification

### Execution Block structure and validity

Upon activation of this EIP, execution clients **MUST** extend the header schema with an
additional 64-bit field: the `target_blob_count`. This values is set to the one provided by the CL with the modified engine api fcU's payload attributes.

Validity of these values is guaranteed from the consensus layer, much like how withdrawals are handled. Hence when verifying a block, execution clients **MUST** ensure the target blob count in the block header matches the one provided by the consensus client.

For a genesis block with no existing parent, the value should be set according to the agreed specification for the target blob count given by that genesis block's protocol rule set.

`excess_blob_gas` in the block now holds _normalized_ excess blob gas accumulating `((blob_gas_used-target_blob_gas)/T) * EXCESS_BLOB_GAS_NORMALIZATION_FACTOR`. We choose `EXCESS_BLOB_GAS_NORMALIZATION_FACTOR` to `100E6` and this makes our choice of `NORMALIZED_BLOB_BASE_FEE_UPDATE_FRACTION` as `3338477 * 100E6 // 393216 = 849018605`.

At the fork block (where parent.timestamp < FORK_TIMESTAMP), we convert parent's accumulated `excess_blob_gas` to the normalized `excess_blob_gas` to be used in this block's `excess_blob_gas` accumulator.

```python
def calc_excess_blob_gas(block: Header) -> int:
  if(block.parent.timestamp < FORK_TIMESTAMP)
    normalizedParentExcessBlobGas = block.parent.excess_blob_gas * 100E6 // 393216
    blockTargetBlobGas = TARGET_BLOB_GAS_PER_BLOCK
  else
    normalizedParentExcessBlobGas = block.parent.excess_blob_gas
    blockTargetBlobGas = block.target_blob_count * GAS_PER_BLOB

  return (normalizedParentExcessBlobGas + (block.blob_gas_used - blockTargetBlobGas) * 100E6 // blockTargetBlobGas)

def get_base_fee_per_blob_gas(parent: Header) -> int:
  return fake_exponential(
        MIN_BASE_FEE_PER_BLOB_GAS,
        parent.excess_blob_gas,
        NORMALIZED_BLOB_BASE_FEE_UPDATE_FRACTION
    )
```

### Block processing

Upon activating this EIP (i.e. before processing any transactions),
the verification of the blob maximum as given in EIP-4844 can be skipped. Concretely, this means any logic relating
to `MAX_BLOB_GAS_PER_BLOCK` as given in EIP-4844 can be deprecated.
Additionally, any reference to `TARGET_BLOB_GAS_PER_BLOCK` from EIP-4844 can be derived by taking the `target_blob_count` from the CL and multiplying by `GAS_PER_BLOB` as given in EIP-4844.

Block `excess_blob_gas` and blob fees charged are now validated as per the new normalized calculations.

Otherwise, the specification of EIP-4844 is not changed. For example, blob base fee accounting and excess blob gas tracking occur in the exact same way.

### Block construction

The Engine API is extended to provide both the `target_blob_count` and the `maximum_blob_count` when the CL requests the EL to construct a payload for proposal.

These values should be used to ensure the correct number of blobs are included in any constructed payload, and to ensure that the blob base fee accounting is correctly computed.

## Rationale

### Why not have the CL also compute the blob base fee and remove any notion of blob counts from EL processing?

Hoisting the full computation into the CL is possible, but it does violate the separation of concerns between these two layers of the protocol stack.
The CL maintains a maximum value to address e.g. DoS risks, and the EL maintains knowledge of the target value to address fee accounting.
Putting the target computation in the CL violates the respective responsibilities of each layer.

## Backwards Compatibility

No issues.

## Test Cases

N/A

## Reference Implementation

N/A

## Security Considerations

N/A

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
